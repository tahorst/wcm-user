#! /usr/bin/env python

"""
ODE network to generate example data for fit_fold_changes.py.
"""

from __future__ import absolute_import, division, print_function

import argparse
import csv
import os
import time

import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import odeint


FILE_LOCATION = os.path.dirname(os.path.realpath(__file__))
DATA_DIR = os.path.join(FILE_LOCATION, 'data')
if not os.path.exists(DATA_DIR):
	os.makedirs(DATA_DIR)
OUTPUT_DIR = os.path.join(FILE_LOCATION, 'out')
if not os.path.exists(OUTPUT_DIR):
	os.makedirs(OUTPUT_DIR)

# Values to test with before real data
## Structure based on sim_data.process.metabolism.reactionStoich
REACTIONS = {
	'r1f': {'a': -1, 'b': 1},
	'r1r': {'b': -1, 'a': 1},
	'r2f': {'a': -1, 'c': 1},
	'r2r': {'c': -1, 'a': 1},
	'r3f': {'c': -1, 'd': -1, 'b': 1, 'e': 1},
	'r3r': {'b': -1, 'e': -1, 'c': 1, 'd': 1},
	'r4f': {'b': -1, 'd': 1},
	'r4r': {'d': -1, 'b': 1},
	'r5f': {'e': -1, 'd': 1},
	'r5r': {'d': -1, 'e': 1},
	}
## Structure based on sim_data.process.metabolism.reactionCatalysts
REACTION_ENZYMES = {
	'r1f': ['e1'],
	'r1r': ['e2'],
	'r2f': ['e3'],
	'r2r': ['e3'],
	'r3f': ['e4'],
	'r3r': ['e4'],
	'r4f': ['e5'],
	'r4r': ['e5'],
	'r5f': ['e6'],
	'r5r': ['e7'],
	}
## Example K_M values for reactants in the reaction network
K_M = {
	'r1f': {'a': 10.},
	'r1r': {'b': 30.},
	'r2f': {'a': 5.},
	'r2r': {'c': 0.5},
	'r3f': {'c': 1., 'd': 5.},
	'r3r': {'b': 2., 'e': 10.},
	'r4f': {'b': 5.},
	'r4r': {'d': 3.},
	'r5f': {'e': 1.},
	'r5r': {'d': 20.},
	}
## Example k_cat values for reactions in the reaction network
K_CAT = {
	'r1f': 2.,
	'r1r': 1.,
	'r2f': 3.,
	'r2r': 0.3,
	'r3f': 10.,
	'r3r': 1.,
	'r4f': 12.,
	'r4r': 5.,
	'r5f': 8.,
	'r5r': 0.5,
	}
# Starting metabolite concentrations
METABOLITE_CONC = {
	'a': 1.,
	'b': 1.,
	'c': 1.,
	'd': 1.,
	'e': 1.,
	}
# Starting enzyme concentrations
ENZYME_CONC = {
	'e1': 5.,
	'e2': 2.,
	'e3': 1.,
	'e4': 10.,
	'e5': 0.1,
	'e6': 50.,
	'e7': 5.,
	}
METABOLITES = sorted(METABOLITE_CONC)
ENZYMES = sorted(ENZYME_CONC)
METABOLITE_INDEX = {m: i for i, m in enumerate(METABOLITES)}
ENZYME_INDEX = {e: i for i, e in enumerate(ENZYMES)}
N_METABOLITES = len(METABOLITES)
N_ENZYMES = len(ENZYMES)


def dcdt(c, t, ko=None, noise=None):
	"""
	Find change in metabolite concentrations.
	"""

	dc = np.zeros(N_METABOLITES)

	if noise is None:
		noise = {}

	for rxn, stoich in REACTIONS.items():
		enzyme = REACTION_ENZYMES[rxn][0]

		# Skip reaction if enzyme is knocked out
		if ko is not None and enzyme == ko:
			continue

		rate = K_CAT[rxn] * ENZYME_CONC[enzyme] * noise.get(enzyme, 1)
		for met, km in K_M[rxn].items():
			conc = c[METABOLITE_INDEX[met]]
			rate *= conc / (km + conc)

		for met, direction in stoich.items():
			dc[METABOLITE_INDEX[met]] += direction * rate

	return dc

def make_noise():
	"""
	Create noise for enzyme expression to use in dcdt.
	"""

	return {e: n for e, n in zip(ENZYMES, np.random.lognormal(0, 0.2, N_ENZYMES))}

def save_results(writer, ko, fc):
	"""
	Save a row to the open tsv writer.
	"""

	ko_array = np.ones(N_ENZYMES)
	if ko is not None:
		ko_array[ENZYME_INDEX[ko]] = 0
	writer.writerow([ko_array.tolist(), fc.tolist()])

def plot_solution(t, sol, ref, label, condition):
	"""
	Plot concentration traces over time.
	"""

	plt.figure()

	# Plot data
	plt.semilogy(t, sol)
	plt.gca().set_prop_cycle(None)
	plt.semilogy([t[0], t[-1]], np.vstack((ref, ref)), '--', linewidth=1)

	# Format plot
	plt.legend(METABOLITES)
	plt.xlabel('Time')
	plt.ylabel('Concentration')

	# Save plot
	filename = '{}_{}'.format(label, condition)
	plt.savefig(os.path.join(OUTPUT_DIR, filename + '.png'))
	plt.close('all')

def parse_args():
	# type: () -> argparse.Namespace
	"""
	Parses arguments from the command line.

	Returns:
		values of variables parsed from the command line
	"""

	parser = argparse.ArgumentParser()

	parser.add_argument('-o', '--output',
		default='ode',
		help='Output filename base (plots and data).')

	return parser.parse_args()

if __name__ == '__main__':
	start = time.time()
	args = parse_args()

	np.set_printoptions(precision=3)
	np.random.seed(0)

	# tsv output file
	output_filename = os.path.join(DATA_DIR, args.output + '.tsv')
	writer = csv.writer(open(output_filename, 'w'), delimiter='\t')
	writer.writerow(['# Generated by {} on {}'.format(__file__, time.asctime())])
	writer.writerow(['# KO for each enzyme will be 1 if present, 0 if knocked out'])
	writer.writerow(['# FC for each metabolite compared to wt condition'])
	writer.writerow(['KO', 'FC'])

	# Parameters
	n_replicates = 5

	# Variables
	co = np.array([METABOLITE_CONC[c] for c in METABOLITES])
	t = np.linspace(0, 100, 10001)

	# WT simulation
	print('Wildtype:')
	ko = None

	## Simulate each replicate for WT
	wt_sol = []
	for it in range(n_replicates):
		sol = odeint(dcdt, co, t, args=(ko, make_noise()))

		# Report results
		wt_sol.append(sol)
		print('  Concentrations: {}'.format(sol[-1, :]))

	## Analyze WT with averaged replicate final concentrations
	wt_final = np.mean([sol[-1, :] for sol in wt_sol], axis=0)
	for i, sol in enumerate(wt_sol):
		# Save results
		fc = sol[-1, :] / wt_final
		save_results(writer, ko, fc)

		# Plot results
		plot_solution(t, sol, wt_final, args.output, 'wt_{}'.format(i))

	# KO simulations
	for ko in ENZYMES:
		print('\nKnockout {}:'.format(ko))
		for it in range(n_replicates):
			sol = odeint(dcdt, co, t, args=(ko, make_noise()))

			# Report results
			c_final = sol[-1, :]
			fc = c_final / wt_final
			print('  Concentrations: {}'.format(c_final))
			print('  Fold changes: {}'.format(fc))
			save_results(writer, ko, fc)

			# Plot results
			plot_solution(t, sol, wt_final, args.output, '{}_{}'.format(ko, it))

	print('Completed in {:.2f} min'.format((time.time() - start) / 60))
