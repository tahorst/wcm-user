Timer unit: 1e-06 s

Total time: 0.078331 s
File: /home/travis/wcEcoli/models/ecoli/processes/metabolism.py
Function: evolveState at line 243

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   243                                           	@line_profile
   244                                           	def evolveState(self):
   245         1         17.0     17.0      0.0  		metaboliteCountsInit = self.metabolites.counts()
   246                                           
   247         1         53.0     53.0      0.1  		cellMass = (self.readFromListener("Mass", "cellMass") * units.fg)
   248         1         24.0     24.0      0.0  		dryMass = (self.readFromListener("Mass", "dryMass") * units.fg)
   249                                           
   250         1         11.0     11.0      0.0  		cellVolume = cellMass / self.cellDensity
   251         1         20.0     20.0      0.0  		countsToMolar = 1 / (self.nAvogadro * cellVolume)
   252                                           
   253                                           		# Coefficient to convert between flux (mol/g DCW/hr) basis and concentration (M) basis
   254         1         34.0     34.0      0.0  		coefficient = dryMass / cellMass * self.cellDensity * (self.timeStepSec() * units.s)
   255                                           
   256                                           		# get boundary conditions
   257         1       1110.0   1110.0      1.4  		self.boundary.updateBoundary()
   258         1          2.0      2.0      0.0  		current_media_id = self.boundary.current_media_id
   259         1          1.0      1.0      0.0  		exchange_data = self.boundary.exchange_data
   260                                           
   261                                           		# make sure there are no new flux targets from the boundary
   262         1         33.0     33.0      0.0  		assert set(self.boundary.transport_fluxes.keys()).issubset(self.all_constrained_reactions)
   263                                           
   264         1          2.0      2.0      0.0  		doubling_time = self.nutrientToDoublingTime.get(current_media_id, self.nutrientToDoublingTime["minimal"])
   265         1          4.0      4.0      0.0  		self.concModificationsBasedOnCondition = self.getBiomassAsConcentrations(doubling_time)
   266                                           
   267         1          2.0      2.0      0.0  		if self.use_trna_charging:
   268         1        322.0    322.0      0.4  			self.concModificationsBasedOnCondition.update(self.update_amino_acid_targets(countsToMolar))
   269         1          2.0      2.0      0.0  		if self.include_ppgpp:
   270         1         72.0     72.0      0.1  			self.concModificationsBasedOnCondition[self.ppgpp_id] = self.getppGppConc(doubling_time)
   271                                           
   272                                           		# Set external molecule levels
   273         1          1.0      1.0      0.0  		externalMoleculeLevels, newObjective = self.exchangeConstraints(
   274         1          2.0      2.0      0.0  			self.externalMoleculeIDs,
   275         1          2.0      2.0      0.0  			coefficient,
   276         1          2.0      2.0      0.0  			CONC_UNITS,
   277         1          1.0      1.0      0.0  			current_media_id,
   278         1          1.0      1.0      0.0  			exchange_data,
   279         1       7154.0   7154.0      9.1  			self.concModificationsBasedOnCondition,
   280                                           			)
   281                                           
   282         1          5.0      5.0      0.0  		if newObjective != None and newObjective != self.homeostaticObjective:
   283         1       4205.0   4205.0      5.4  			self.fba.update_homeostatic_targets(newObjective)
   284         1          4.0      4.0      0.0  			self.homeostaticObjective = newObjective
   285                                           
   286                                           		# After completing the burn-in, enable kinetic rates
   287         1          2.0      2.0      0.0  		if self.use_kinetics and (not self.burnInComplete) and (self._sim.time() > KINETICS_BURN_IN_PERIOD):
   288                                           			self.burnInComplete = True
   289                                           			self.fba.enableKineticTargets()
   290                                           
   291                                           		#  Find metabolite concentrations from metabolite counts
   292         1         23.0     23.0      0.0  		metaboliteConcentrations =  countsToMolar * metaboliteCountsInit[self.internalExchangeIdxs]
   293                                           
   294                                           		# Make a dictionary of metabolite names to metabolite concentrations
   295         1       1390.0   1390.0      1.8  		self.fba.setInternalMoleculeLevels(metaboliteConcentrations.asNumber(CONC_UNITS))
   296                                           
   297                                           		# Set external molecule levels
   298                                           		# TODO -- this can change external AA levels for the fba problem. Problematic for reliable control of environmental response
   299         1       1031.0   1031.0      1.3  		self._setExternalMoleculeLevels(externalMoleculeLevels, metaboliteConcentrations)
   300                                           
   301                                           		# Change the ngam and polypeptide elongation energy penalty only if they are noticably different from the current value
   302         1          2.0      2.0      0.0  		ADJUSTMENT_RATIO = .01
   303                                           
   304                                           		# Calculate new NGAM and update if necessary
   305         1         17.0     17.0      0.0  		self.newNgam = self.ngam * coefficient
   306         1        701.0    701.0      0.9  		ngam_diff = np.abs((self.currentNgam - self.newNgam).asNumber()) / (self.currentNgam.asNumber() + 1e-20)
   307         1          2.0      2.0      0.0  		if ngam_diff > ADJUSTMENT_RATIO:
   308                                           			self.currentNgam = self.newNgam
   309                                           			flux = (self.ngam * coefficient).asNumber(CONC_UNITS)
   310                                           			self.fba.setReactionFluxBounds(self.fba._reactionID_NGAM, lowerBounds=flux, upperBounds=flux)
   311                                           
   312                                           		# Calculate GTP usage based on how much was needed in polypeptide elongation in previous step and update if necessary
   313         1          8.0      8.0      0.0  		newPolypeptideElongationEnergy = countsToMolar * 0
   314         1          4.0      4.0      0.0  		if hasattr(self._sim.processes["PolypeptideElongation"], "gtpRequest"):
   315         1         10.0     10.0      0.0  			newPolypeptideElongationEnergy = countsToMolar * self._sim.processes["PolypeptideElongation"].gtpRequest
   316         1        459.0    459.0      0.6  		poly_diff = np.abs((self.currentPolypeptideElongationEnergy - newPolypeptideElongationEnergy).asNumber()) / (self.currentPolypeptideElongationEnergy.asNumber() + 1e-20)
   317         1          2.0      2.0      0.0  		if poly_diff > ADJUSTMENT_RATIO:
   318                                           			self.currentPolypeptideElongationEnergy = newPolypeptideElongationEnergy
   319                                           			flux = self.currentPolypeptideElongationEnergy.asNumber(CONC_UNITS)
   320                                           			self.fba.setReactionFluxBounds(self.fba._reactionID_polypeptideElongationEnergy, lowerBounds=flux, upperBounds=flux)
   321                                           
   322                                           		# Constrain reactions based on absence of catalysts
   323                                           		## Read counts for catalysts and enzymes (catalysts with kinetics constraints)
   324         1         26.0     26.0      0.0  		catalystsCountsInit = self.catalysts.counts()
   325                                           
   326                                           		## Set hard upper bounds constraints based on enzyme presence (infinite upper bound) or absence (upper bound of zero)
   327         1         19.0     19.0      0.0  		catalyzedReactionBounds = np.inf * np.ones(len(self.reactionsWithCatalystsList))
   328         1         53.0     53.0      0.1  		rxnPresence = self.catalysisMatrix.dot(catalystsCountsInit)
   329         1         10.0     10.0      0.0  		catalyzedReactionBounds[rxnPresence == 0] = 0
   330         1          1.0      1.0      0.0  		if self.shuffleCatalyzedIdxs is not None:
   331                                           			catalyzedReactionBounds = catalyzedReactionBounds[self.shuffleCatalyzedIdxs]
   332                                           
   333                                           		## Only update reaction limits that are different from previous time step
   334         1          7.0      7.0      0.0  		updateIdxs = np.where(catalyzedReactionBounds != self.catalyzedReactionBoundsPrev)[0]
   335         1          6.0      6.0      0.0  		updateRxns = [self.reactionsWithCatalystsList[idx] for idx in updateIdxs]
   336         1          2.0      2.0      0.0  		updateVals = catalyzedReactionBounds[updateIdxs]
   337         1          8.0      8.0      0.0  		self.fba.setReactionFluxBounds(updateRxns, upperBounds=updateVals, raiseForReversible=False)
   338         1          2.0      2.0      0.0  		self.catalyzedReactionBoundsPrev = catalyzedReactionBounds
   339                                           
   340                                           		# Constrain reactions based on kinetic values
   341         1         11.0     11.0      0.0  		kineticsEnzymesCountsInit = self.kineticsEnzymes.counts()
   342         1         13.0     13.0      0.0  		kineticsEnzymesConcentrations = countsToMolar * kineticsEnzymesCountsInit
   343                                           
   344         1          7.0      7.0      0.0  		kineticsSubstratesCountsInit = self.kineticsSubstrates.counts()
   345         1          9.0      9.0      0.0  		kineticsSubstratesConcentrations = countsToMolar * kineticsSubstratesCountsInit
   346                                           
   347                                           		## Set target fluxes for reactions based on their most relaxed constraint
   348         1          1.0      1.0      0.0  		constraintValues = self.getKineticConstraints(
   349         1        268.0    268.0      0.3  			kineticsEnzymesConcentrations.asNumber(units.umol / units.L),
   350         1        469.0    469.0      0.6  			kineticsSubstratesConcentrations.asNumber(units.umol / units.L),
   351                                           			)
   352         1        369.0    369.0      0.5  		reactionTargets = (units.umol / units.L / units.s) * np.max(self.constraintToReactionMatrix * constraintValues, axis = 1)
   353                                           
   354                                           		## Shuffle parameters (only performed in very specific cases)
   355         1          2.0      2.0      0.0  		if self.shuffleIdxs is not None:
   356                                           			reactionTargets = (units.umol / units.L / units.s) * reactionTargets.asNumber()[self.shuffleIdxs]
   357                                           
   358                                           		## Record which constraint was used, add constraintToReactionMatrix to ensure the index is one of the constraints if multiplication is 0
   359         1        381.0    381.0      0.5  		reactionConstraint = np.argmax(self.constraintToReactionMatrix * constraintValues + self.constraintToReactionMatrix, axis = 1)
   360                                           
   361                                           		## Calculate reaction flux target for current time step
   362         1        154.0    154.0      0.2  		targets = (TIME_UNITS * self.timeStepSec() * reactionTargets).asNumber(CONC_UNITS)[self.active_constraints_mask]
   363                                           
   364                                           		# add boundary targets
   365         1          9.0      9.0      0.0  		all_targets = np.concatenate((targets, self.boundary.transport_fluxes.values()), axis=0)
   366                                           
   367                                           		## Set kinetic targets only if kinetics is enabled
   368         1          1.0      1.0      0.0  		if self.use_kinetics and self.burnInComplete:
   369         1       5261.0   5261.0      6.7  			self.fba.setKineticTarget(self.all_constrained_reactions, all_targets, raiseForReversible = False)
   370                                           
   371                                           		# Solve FBA problem and update metabolite counts
   372         1      42124.0  42124.0     53.8  		deltaMetabolites = (1 / countsToMolar) * (CONC_UNITS * self.fba.getOutputMoleculeLevelsChange())
   373                                           
   374         1         16.0     16.0      0.0  		metaboliteCountsFinal = np.zeros_like(metaboliteCountsInit)
   375         1          2.0      2.0      0.0  		metaboliteCountsFinal[self.internalExchangeIdxs] = np.fmax(stochasticRound(
   376         1          2.0      2.0      0.0  			self.randomState,
   377         1        299.0    299.0      0.4  			metaboliteCountsInit[self.internalExchangeIdxs] + deltaMetabolites.asNumber()
   378         1          8.0      8.0      0.0  			), 0).astype(np.int64)
   379                                           
   380         1         18.0     18.0      0.0  		self.metabolites.countsIs(metaboliteCountsFinal)
   381                                           
   382         1         47.0     47.0      0.1  		exchange_fluxes = CONC_UNITS * self.fba.getExternalExchangeFluxes()
   383         1        125.0    125.0      0.2  		converted_exchange_fluxes = (exchange_fluxes / coefficient).asNumber(units.mmol / units.g / units.h)
   384                                           
   385                                           		# update environmental nutrient counts
   386         1        235.0    235.0      0.3  		delta_nutrients = ((1 / countsToMolar) * exchange_fluxes).asNumber().astype(int)
   387         1          3.0      3.0      0.0  		external_exchange_molecule_ids = self.fba.getExternalMoleculeIDs()
   388         1         74.0     74.0      0.1  		self.boundary.updateEnvironment(external_exchange_molecule_ids, delta_nutrients)
   389                                           
   390         1         51.0     51.0      0.1  		import_exchange, import_constraint = self.boundary.getImportConstraints(exchange_data)
   391                                           
   392                                           		# Write outputs to listeners
   393         1         19.0     19.0      0.0  		self.writeToListener("FBAResults", "import_exchange", import_exchange)
   394         1          7.0      7.0      0.0  		self.writeToListener("FBAResults", "import_constraint", import_constraint)
   395         1         11.0     11.0      0.0  		self.writeToListener("FBAResults", "deltaMetabolites", metaboliteCountsFinal - metaboliteCountsInit)
   396         1       1041.0   1041.0      1.3  		self.writeToListener("FBAResults", "reactionFluxes", self.fba.getReactionFluxes() / self.timeStepSec())
   397         1          5.0      5.0      0.0  		self.writeToListener("FBAResults", "externalExchangeFluxes", converted_exchange_fluxes)
   398         1          9.0      9.0      0.0  		self.writeToListener("FBAResults", "objectiveValue", self.fba.getObjectiveValue())
   399         1        120.0    120.0      0.2  		self.writeToListener("FBAResults", "shadowPrices", self.fba.getShadowPrices(self.metaboliteNames))
   400         1       2703.0   2703.0      3.5  		self.writeToListener("FBAResults", "reducedCosts", self.fba.getReducedCosts(self.fba.getReactionIDs()))
   401       143        275.0      1.9      0.4  		self.writeToListener("FBAResults", "targetConcentrations", [self.homeostaticObjective[mol] for mol in self.fba.getHomeostaticTargetMolecules()])
   402         1       1699.0   1699.0      2.2  		self.writeToListener("FBAResults", "homeostaticObjectiveValues", self.fba.getHomeostaticObjectiveValues())
   403         1       4777.0   4777.0      6.1  		self.writeToListener("FBAResults", "kineticObjectiveValues", self.fba.getKineticObjectiveValues())
   404                                           
   405         1          7.0      7.0      0.0  		self.writeToListener("EnzymeKinetics", "metaboliteCountsInit", metaboliteCountsInit)
   406         1          6.0      6.0      0.0  		self.writeToListener("EnzymeKinetics", "metaboliteCountsFinal", metaboliteCountsFinal)
   407         1          6.0      6.0      0.0  		self.writeToListener("EnzymeKinetics", "enzymeCountsInit", kineticsEnzymesCountsInit)
   408         1        299.0    299.0      0.4  		self.writeToListener("EnzymeKinetics", "metaboliteConcentrations", metaboliteConcentrations.asNumber(CONC_UNITS))
   409         1        242.0    242.0      0.3  		self.writeToListener("EnzymeKinetics", "countsToMolar", countsToMolar.asNumber(CONC_UNITS))
   410         1        250.0    250.0      0.3  		self.writeToListener("EnzymeKinetics", "actualFluxes", self.fba.getReactionFluxes(self.all_constrained_reactions) / self.timeStepSec())
   411         1         13.0     13.0      0.0  		self.writeToListener("EnzymeKinetics", "targetFluxes", all_targets / self.timeStepSec())
   412         1         12.0     12.0      0.0  		self.writeToListener("EnzymeKinetics", "reactionConstraint", reactionConstraint[self.active_constraints_mask])

